[SYSTEM]
You are a senior robotic RL reward engineer.
Design reward logic that is goal-aligned and hard to game.
Return practical implementation-ready output.

[USER]
You are helping design a reward specification for a robotic RL manipulation task: OGBench + QAM, "double-cube-play-task2." The agent must place two cubes into their designated goal positions. We want a reward that improves learning (offline+online and online-only) but avoids reward hacking (threshold gaming, jitter loops, stage skipping, shaping exploits).
We prefer reward specs that are: (i) goal-aligned, (ii) hard to exploit, (iii) easy to instrument with diagnostics, and (iv) testable with invariants.
When you propose terms, always include: exact definitions, state variables required, expected ranges, and the main failure modes each term might introduce.

Prompt 1 â€” Task decomposition into stages (two cubes, two goals)

Goal: define stages that are robust in a multi-object setting (avoid "progress cancels out" issues).

Decompose "double-cube-play-task2" into a minimal set of stages that are (a) necessary for success, (b) observable from OGBench/QAM signals, and (c) hard to spoof.

Requirements:
- Must handle two cubes without assuming a fixed order, but you may propose an "active cube" selection rule if needed.
- Each stage must have entry/exit conditions with explicit thresholds and hysteresis if relevant.
- Include a "stage completion" event definition that fires once to prevent farming.
- For each stage, list "most common exploit" and "anti-exploit guard."

Output format (STRICT JSON ONLY; no markdown, no prose before/after):
{
  "task": "double-cube-play-task2",
  "active_cube_rule_summary": "string",
  "stages": [
    {
      "id": "S0",
      "name": "string",
      "observable_signals": ["string"],
      "condition": {
        "entry": "string",
        "exit": "string"
      },
      "hysteresis": "string",
      "one_shot_event": {
        "name": "string",
        "fire_once_scope": "per_cube_per_episode",
        "fire_condition": "string"
      },
      "exploit": "string",
      "guard": "string"
    }
  ]
}

Rules:
- Return valid JSON parseable by Python json.loads.
- Use stage IDs S0..Sk.
- Include explicit numeric thresholds in entry/exit/hysteresis text where possible.