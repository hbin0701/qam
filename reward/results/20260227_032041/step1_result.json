{
  "system_prompt": "You are an expert robotic RL reward engineer.\nYou design structured, spatially grounded subtask representations for manipulation environments.\n\nYou write deterministic, implementation-ready Python.\nYou prioritize simplicity, geometric interpretability, and task generality.\n\nReturn code only.",
  "user_prompt": "You are given:\n\n1) Environment implementation code describing objects, state structure, and available signals.\n2) (Optional) Demonstration trajectories or rollout videos for context.\n\nTask:\nGenerate Python code that defines a structured subtask and progress representation for this environment.\n\nYou must implement:\n\n- propose_substages() -> list[str]\n- determine_subtask(prev_env, curr_env) -> int\n- measure_subtask_progress(prev_env, curr_env, subtask_id) -> float\n- determine_subtask_and_progress(prev_env, curr_env) -> tuple[int, float]\n\nDesign principles:\n\n1) Subtasks should correspond to semantically meaningful phases of task completion and decompose the task into interpretable intermediate objectives.\n\n2) The representation must:\n  - Be deterministic.\n  - Use only information available in prev_env and curr_env.\n  - Avoid assumptions or signals not present in the environment specification.\n\n3) Spatial grounding:\n  - Subtask transitions and progress measures must be derived from observable spatial relationships between task-relevant entities.\n  - Use geometric quantities such as relative distances, spatial proximity, height differences, or motion patterns.\n  - The resulting representation should remain interpretable.\n\n4) Progress:\n  - measure_subtask_progress must return a float in [0, 1].\n  - Progress should reflect advancement toward completion of the current subtask.\n\n5) Generality:\n  - The representation should remain valid and interpretable in environments involving multiple task-relevant objects.\n  - The decomposition should remain compact and avoid unnecessary fragmentation.\n\nAvailable geometric utilities (executable API):\n\n- get_position(src, object_name, ...)\n- get_dist_xy(a, b)\n- get_dist_xyz(a, b)\n\nThese utilities serve two purposes:\n\n1) During code generation, you may call them to inspect geometric quantities\n  (e.g., from demonstration trajectories) in order to estimate task-relevant\n  thresholds or reference values.\n\n2) In the generated implementation, you should use these functions directly\n  inside the subtask and progress logic when computing spatial relationships\n  between objects.\n\nEnvironment code:\n```python\n\"\"\"\nEnvironment schema for cube-double tasks.\n\nThis module intentionally models environment entities only (no reward logic).\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import Dict, Mapping, Sequence\n\n# Success criterion (task-level): object is successful if within threshold of goal.\nCUBE_SUCCESS_THRESHOLD = 0.04  # meters\nNUM_CUBES = 2\nTOOL_OBJECT_NAMES = (\"cube_0\", \"cube_1\", \"gripper\", \"goal_0\", \"goal_1\")\nENV_OBJECT_NAMES = TOOL_OBJECT_NAMES\n\n@dataclass\nclass Vector3D:\n    x: float\n    y: float\n    z: float\n\n    @classmethod\n    def from_any(cls, v: \"Vector3D | Sequence[float]\") -> \"Vector3D\":\n        if isinstance(v, cls):\n            return cls(v.x, v.y, v.z)\n        vals = list(v)\n        if len(vals) != 3:\n            raise ValueError(f\"Expected 3 values, got {len(vals)}\")\n        return cls(float(vals[0]), float(vals[1]), float(vals[2]))\n\n    def to_tuple(self) -> tuple[float, float, float]:\n        return (self.x, self.y, self.z)\n\n\n@dataclass\nclass Goal:\n    name: str\n    position: Vector3D\n\n    def __post_init__(self) -> None:\n        self.position = Vector3D.from_any(self.position)\n\n\n@dataclass\nclass Finger:\n    name: str\n    position: Vector3D\n\n    def __post_init__(self) -> None:\n        self.position = Vector3D.from_any(self.position)\n\n\n@dataclass\nclass Gripper:\n    position: Vector3D\n    left: Finger\n    right: Finger\n\n    def __post_init__(self) -> None:\n        self.position = Vector3D.from_any(self.position)\n\n\n@dataclass\nclass Cube:\n    name: str\n    position: Vector3D\n\n    def __post_init__(self) -> None:\n        self.position = Vector3D.from_any(self.position)\n\n\nEXPECTED_OBJECT_TYPES = {\n    \"cube_0\": Cube,\n    \"cube_1\": Cube,\n    \"gripper\": Gripper,\n    \"goal_0\": Goal,\n    \"goal_1\": Goal,\n}\n\n\nclass Env:\n    \"\"\"Base environment entity container.\"\"\"\n\n    def __init__(\n        self,\n        objects: Dict[str, object] | None = None,\n        success_threshold: float = CUBE_SUCCESS_THRESHOLD,\n    ):\n        self.success_threshold = float(success_threshold)\n        self._objects: Dict[str, object] = dict(objects or {})\n        self._validate_required_objects()\n\n    def _validate_required_objects(self) -> None:\n        missing = [name for name in ENV_OBJECT_NAMES if name not in self._objects]\n        if missing:\n            raise ValueError(\n                f\"Env is missing required objects: {missing}. \"\n                f\"Required object names are: {ENV_OBJECT_NAMES}\"\n            )\n        for name in ENV_OBJECT_NAMES:\n            obj = self._objects[name]\n            expected_t = EXPECTED_OBJECT_TYPES.get(name)\n            if expected_t is not None and not isinstance(obj, expected_t):\n                raise ValueError(\n                    f\"Object {name!r} must be of type {expected_t.__name__}, \"\n                    f\"got {type(obj).__name__}\"\n                )\n            if not hasattr(obj, \"position\"):\n                raise ValueError(f\"Object {name!r} must have a 'position' field\")\n            # Ensure position is parseable as Vector3D.\n            Vector3D.from_any(getattr(obj, \"position\"))\n\n    def get_object(self, name: str) -> object:\n        if name not in self._objects:\n            raise KeyError(f\"Unknown object {name!r}. Available: {sorted(self._objects)}\")\n        return self._objects[name]\n\n    def get_position(self, object_name: str) -> Vector3D:\n        obj = self.get_object(object_name)\n        if not hasattr(obj, \"position\"):\n            raise AttributeError(f\"Object {object_name!r} has no position field\")\n        return Vector3D.from_any(getattr(obj, \"position\"))\n\n    @property\n    def object_names(self) -> tuple[str, ...]:\n        return tuple(self._objects.keys())\n\n\nclass Demo:\n    \"\"\"Demo/video trace container indexed by frame number.\"\"\"\n\n    def __init__(\n        self,\n        frames: Mapping[int, Mapping[str, Sequence[float] | Vector3D]] | None = None,\n    ):\n        self._frames: Dict[int, Dict[str, Vector3D]] = {}\n        for frame_num, obj_map in (frames or {}).items():\n            per_frame: Dict[str, Vector3D] = {}\n            for object_name, pos in obj_map.items():\n                per_frame[str(object_name)] = Vector3D.from_any(pos)\n            self._frames[int(frame_num)] = per_frame\n\n    def get_position(self, frame_num: int, object_name: str) -> Vector3D:\n        frame = self._frames.get(int(frame_num))\n        if frame is None:\n            raise KeyError(f\"Unknown frame_num {frame_num}\")\n        if object_name not in frame:\n            raise KeyError(f\"Unknown object {object_name!r} in frame {frame_num}\")\n        return frame[object_name]\n\n    @property\n    def frame_numbers(self) -> tuple[int, ...]:\n        return tuple(sorted(self._frames.keys()))\n\n\ndef get_position(\n    src: str,\n    object_name: str,\n    *,\n    env: Env | None = None,\n    demo: Demo | None = None,\n    frame_num: int | None = None,\n) -> Vector3D:\n    \"\"\"Unified position accessor for env/demo sources.\n\n    - src='env': uses Env.get_position(object_name).\n    - src='demo': uses Demo.get_position(frame_num, object_name). frame_num required.\n    \"\"\"\n    mode = str(src).lower()\n    if mode == \"env\":\n        if env is None:\n            raise ValueError(\"env source requested but env is None\")\n        return env.get_position(object_name)\n    if mode == \"demo\":\n        if demo is None:\n            raise ValueError(\"demo source requested but demo is None\")\n        if frame_num is None:\n            raise ValueError(\"frame_num is required when src='demo'\")\n        return demo.get_position(frame_num=frame_num, object_name=object_name)\n    raise ValueError(f\"Unknown src {src!r}; expected 'env' or 'demo'\")\n\n```\n\nOutput format (STRICT):\nReturn exactly one fenced python block and nothing else.",
  "video_path": "/rlwrld3/home/hyeonbin/RL/qam/artifacts/double_demo.mp4",
  "sampled_frame_indices": [
    0,
    2,
    4,
    6,
    8,
    10,
    12,
    14,
    16,
    18,
    20,
    22,
    24,
    26,
    28,
    30,
    32,
    34,
    36,
    38,
    40,
    42,
    44,
    46,
    48,
    50,
    52,
    54,
    56,
    58,
    60,
    63
  ],
  "tool_trace": [],
  "raw_response": "```python\ndef propose_substages() -> list[str]:\n    return [\n        \"move_to_cube_0\",\n        \"pick_cube_0\",\n        \"move_cube_0_to_goal_0\",\n        \"place_cube_0_at_goal_0\",\n        \"move_to_cube_1\",\n        \"pick_cube_1\",\n        \"move_cube_1_to_goal_1\",\n        \"place_cube_1_at_goal_1\",\n    ]\n\n\ndef determine_subtask(prev_env, curr_env) -> int:\n    gripper_pos = default_api.get_position(src=\"env\", object_name=\"gripper\", time_ref=\"curr\")\n    cube_0_pos = default_api.get_position(src=\"env\", object_name=\"cube_0\", time_ref=\"curr\")\n    cube_1_pos = default_api.get_position(src=\"env\", object_name=\"cube_1\", time_ref=\"curr\")\n    goal_0_pos = default_api.get_position(src=\"env\", object_name=\"goal_0\", time_ref=\"curr\")\n    goal_1_pos = default_api.get_position(src=\"env\", object_name=\"goal_1\", time_ref=\"curr\")\n\n    dist_gripper_to_cube_0 = default_api.get_dist_xyz(gripper_pos.to_tuple(), cube_0_pos.to_tuple())[\"distance\"]\n    dist_cube_0_to_goal_0 = default_api.get_dist_xyz(cube_0_pos.to_tuple(), goal_0_pos.to_tuple())[\"distance\"]\n    dist_gripper_to_cube_1 = default_api.get_dist_xyz(gripper_pos.to_tuple(), cube_1_pos.to_tuple())[\"distance\"]\n    dist_cube_1_to_goal_1 = default_api.get_dist_xyz(cube_1_pos.to_tuple(), goal_1_pos.to_tuple())[\"distance\"]\n\n    # Thresholds\n    GRIPPER_CUBE_THRESHOLD = 0.05\n    CUBE_GOAL_THRESHOLD = 0.04\n\n    # Subtask 0: move_to_cube_0\n    if dist_gripper_to_cube_0 > GRIPPER_CUBE_THRESHOLD and dist_cube_0_to_goal_0 > CUBE_GOAL_THRESHOLD:\n        return 0\n    # Subtask 1: pick_cube_0\n    elif dist_gripper_to_cube_0 <= GRIPPER_CUBE_THRESHOLD and dist_cube_0_to_goal_0 > CUBE_GOAL_THRESHOLD:\n        return 1\n    # Subtask 2: move_cube_0_to_goal_0\n    elif dist_gripper_to_cube_0 <= GRIPPER_CUBE_THRESHOLD and dist_cube_0_to_goal_0 > CUBE_GOAL_THRESHOLD:\n        return 2\n    # Subtask 3: place_cube_0_at_goal_0\n    elif dist_cube_0_to_goal_0 <= CUBE_GOAL_THRESHOLD and dist_gripper_to_cube_0 > GRIPPER_CUBE_THRESHOLD:\n        return 3\n    # Subtask 4: move_to_cube_1\n    elif dist_gripper_to_cube_1 > GRIPPER_CUBE_THRESHOLD and dist_cube_1_to_goal_1 > CUBE_GOAL_THRESHOLD:\n        return 4\n    # Subtask 5: pick_cube_1\n    elif dist_gripper_to_cube_1 <= GRIPPER_CUBE_THRESHOLD and dist_cube_1_to_goal_1 > CUBE_GOAL_THRESHOLD:\n        return 5\n    # Subtask 6: move_cube_1_to_goal_1\n    elif dist_gripper_to_cube_1 <= GRIPPER_CUBE_THRESHOLD and dist_cube_1_to_goal_1 > CUBE_GOAL_THRESHOLD:\n        return 6\n    # Subtask 7: place_cube_1_at_goal_1\n    elif dist_cube_1_to_goal_1 <= CUBE_GOAL_THRESHOLD and dist_gripper_to_cube_1 > GRIPPER_CUBE_THRESHOLD:\n        return 7\n    return 0\n\n\ndef measure_subtask_progress(prev_env, curr_env, subtask_id) -> float:\n    gripper_pos = default_api.get_position(src=\"env\", object_name=\"gripper\", time_ref=\"curr\")\n    cube_0_pos = default_api.get_position(src=\"env\", object_name=\"cube_0\", time_ref=\"curr\")\n    cube_1_pos = default_api.get_position(src=\"env\", object_name=\"cube_1\", time_ref=\"curr\")\n    goal_0_pos = default_api.get_position(src=\"env\", object_name=\"goal_0\", time_ref=\"curr\")\n    goal_1_pos = default_api.get_position(src=\"env\", object_name=\"goal_1\", time_ref=\"curr\")\n\n    # Thresholds\n    GRIPPER_CUBE_THRESHOLD = 0.05\n    CUBE_GOAL_THRESHOLD = 0.04\n\n    if subtask_id == 0:  # move_to_cube_0\n        dist = default_api.get_dist_xyz(gripper_pos.to_tuple(), cube_0_pos.to_tuple())[\"distance\"]\n        initial_dist = default_api.get_dist_xyz(\n            default_api.get_position(src=\"env\", object_name=\"gripper\", time_ref=\"prev\").to_tuple(),\n            default_api.get_position(src=\"env\", object_name=\"cube_0\", time_ref=\"prev\").to_tuple(),\n        )[\"distance\"]\n        progress = 1.0 - (dist / initial_dist) if initial_dist > 0 else 1.0\n        return max(0.0, min(1.0, progress))\n    elif subtask_id == 1:  # pick_cube_0\n        dist = default_api.get_dist_xyz(gripper_pos.to_tuple(), cube_0_pos.to_tuple())[\"distance\"]\n        return max(0.0, min(1.0, 1.0 - (dist / GRIPPER_CUBE_THRESHOLD)))\n    elif subtask_id == 2:  # move_cube_0_to_goal_0\n        dist = default_api.get_dist_xyz(cube_0_pos.to_tuple(), goal_0_pos.to_tuple())[\"distance\"]\n        initial_dist = default_api.get_dist_xyz(\n            default_api.get_position(src=\"env\", object_name=\"cube_0\", time_ref=\"prev\").to_tuple(),\n            default_api.get_position(src=\"env\", object_name=\"goal_0\", time_ref=\"prev\").to_tuple(),\n        )[\"distance\"]\n        progress = 1.0 - (dist / initial_dist) if initial_dist > 0 else 1.0\n        return max(0.0, min(1.0, progress))\n    elif subtask_id == 3:  # place_cube_0_at_goal_0\n        dist = default_api.get_dist_xyz(cube_0_pos.to_tuple(), goal_0_pos.to_tuple())[\"distance\"]\n        return max(0.0, min(1.0, 1.0 - (dist / CUBE_GOAL_THRESHOLD)))\n    elif subtask_id == 4:  # move_to_cube_1\n        dist = default_api.get_dist_xyz(gripper_pos.to_tuple(), cube_1_pos.to_tuple())[\"distance\"]\n        initial_dist = default_api.get_dist_xyz(\n            default_api.get_position(src=\"env\", object_name=\"gripper\", time_ref=\"prev\").to_tuple(),\n            default_api.get_position(src=\"env\", object_name=\"cube_1\", time_ref=\"prev\").to_tuple(),\n        )[\"distance\"]\n        progress = 1.0 - (dist / initial_dist) if initial_dist > 0 else 1.0\n        return max(0.0, min(1.0, progress))\n    elif subtask_id == 5:  # pick_cube_1\n        dist = default_api.get_dist_xyz(gripper_pos.to_tuple(), cube_1_pos.to_tuple())[\"distance\"]\n        return max(0.0, min(1.0, 1.0 - (dist / GRIPPER_CUBE_THRESHOLD)))\n    elif subtask_id == 6:  # move_cube_1_to_goal_1\n        dist = default_api.get_dist_xyz(cube_1_pos.to_tuple(), goal_1_pos.to_tuple())[\"distance\"]\n        initial_dist = default_api.get_dist_xyz(\n            default_api.get_position(src=\"env\", object_name=\"cube_1\", time_ref=\"prev\").to_tuple(),\n            default_api.get_position(src=\"env\", object_name=\"goal_1\", time_ref=\"prev\").to_tuple(),\n        )[\"distance\"]\n        progress = 1.0 - (dist / initial_dist) if initial_dist > 0 else 1.0\n        return max(0.0, min(1.0, progress))\n    elif subtask_id == 7:  # place_cube_1_at_goal_1\n        dist = default_api.get_dist_xyz(cube_1_pos.to_tuple(), goal_1_pos.to_tuple())[\"distance\"]\n        return max(0.0, min(1.0, 1.0 - (dist / CUBE_GOAL_THRESHOLD)))\n    return 0.0\n\n\ndef determine_subtask_and_progress(prev_env, curr_env) -> tuple[int, float]:\n    subtask_id = determine_subtask(prev_env, curr_env)\n    progress = measure_subtask_progress(prev_env, curr_env, subtask_id)\n    return subtask_id, progress\n\n```",
  "response_debug": {
    "response_text_len": 6509,
    "finish_reasons": [
      "STOP"
    ],
    "usage_metadata": {
      "prompt_token_count": 11406,
      "candidates_token_count": 2451,
      "thoughts_token_count": 0,
      "total_token_count": 13857
    },
    "prompt_feedback": {
      "block_reason": null,
      "safety_ratings": null
    },
    "candidates": [
      {
        "index": 0,
        "finish_reason": "STOP",
        "safety_ratings": null,
        "part_count": 1,
        "function_call_count": 0,
        "text_part_lengths": [
          6509
        ]
      }
    ]
  },
  "parsed_json": null,
  "python_code": "def propose_substages() -> list[str]:\n    return [\n        \"move_to_cube_0\",\n        \"pick_cube_0\",\n        \"move_cube_0_to_goal_0\",\n        \"place_cube_0_at_goal_0\",\n        \"move_to_cube_1\",\n        \"pick_cube_1\",\n        \"move_cube_1_to_goal_1\",\n        \"place_cube_1_at_goal_1\",\n    ]\n\n\ndef determine_subtask(prev_env, curr_env) -> int:\n    gripper_pos = default_api.get_position(src=\"env\", object_name=\"gripper\", time_ref=\"curr\")\n    cube_0_pos = default_api.get_position(src=\"env\", object_name=\"cube_0\", time_ref=\"curr\")\n    cube_1_pos = default_api.get_position(src=\"env\", object_name=\"cube_1\", time_ref=\"curr\")\n    goal_0_pos = default_api.get_position(src=\"env\", object_name=\"goal_0\", time_ref=\"curr\")\n    goal_1_pos = default_api.get_position(src=\"env\", object_name=\"goal_1\", time_ref=\"curr\")\n\n    dist_gripper_to_cube_0 = default_api.get_dist_xyz(gripper_pos.to_tuple(), cube_0_pos.to_tuple())[\"distance\"]\n    dist_cube_0_to_goal_0 = default_api.get_dist_xyz(cube_0_pos.to_tuple(), goal_0_pos.to_tuple())[\"distance\"]\n    dist_gripper_to_cube_1 = default_api.get_dist_xyz(gripper_pos.to_tuple(), cube_1_pos.to_tuple())[\"distance\"]\n    dist_cube_1_to_goal_1 = default_api.get_dist_xyz(cube_1_pos.to_tuple(), goal_1_pos.to_tuple())[\"distance\"]\n\n    # Thresholds\n    GRIPPER_CUBE_THRESHOLD = 0.05\n    CUBE_GOAL_THRESHOLD = 0.04\n\n    # Subtask 0: move_to_cube_0\n    if dist_gripper_to_cube_0 > GRIPPER_CUBE_THRESHOLD and dist_cube_0_to_goal_0 > CUBE_GOAL_THRESHOLD:\n        return 0\n    # Subtask 1: pick_cube_0\n    elif dist_gripper_to_cube_0 <= GRIPPER_CUBE_THRESHOLD and dist_cube_0_to_goal_0 > CUBE_GOAL_THRESHOLD:\n        return 1\n    # Subtask 2: move_cube_0_to_goal_0\n    elif dist_gripper_to_cube_0 <= GRIPPER_CUBE_THRESHOLD and dist_cube_0_to_goal_0 > CUBE_GOAL_THRESHOLD:\n        return 2\n    # Subtask 3: place_cube_0_at_goal_0\n    elif dist_cube_0_to_goal_0 <= CUBE_GOAL_THRESHOLD and dist_gripper_to_cube_0 > GRIPPER_CUBE_THRESHOLD:\n        return 3\n    # Subtask 4: move_to_cube_1\n    elif dist_gripper_to_cube_1 > GRIPPER_CUBE_THRESHOLD and dist_cube_1_to_goal_1 > CUBE_GOAL_THRESHOLD:\n        return 4\n    # Subtask 5: pick_cube_1\n    elif dist_gripper_to_cube_1 <= GRIPPER_CUBE_THRESHOLD and dist_cube_1_to_goal_1 > CUBE_GOAL_THRESHOLD:\n        return 5\n    # Subtask 6: move_cube_1_to_goal_1\n    elif dist_gripper_to_cube_1 <= GRIPPER_CUBE_THRESHOLD and dist_cube_1_to_goal_1 > CUBE_GOAL_THRESHOLD:\n        return 6\n    # Subtask 7: place_cube_1_at_goal_1\n    elif dist_cube_1_to_goal_1 <= CUBE_GOAL_THRESHOLD and dist_gripper_to_cube_1 > GRIPPER_CUBE_THRESHOLD:\n        return 7\n    return 0\n\n\ndef measure_subtask_progress(prev_env, curr_env, subtask_id) -> float:\n    gripper_pos = default_api.get_position(src=\"env\", object_name=\"gripper\", time_ref=\"curr\")\n    cube_0_pos = default_api.get_position(src=\"env\", object_name=\"cube_0\", time_ref=\"curr\")\n    cube_1_pos = default_api.get_position(src=\"env\", object_name=\"cube_1\", time_ref=\"curr\")\n    goal_0_pos = default_api.get_position(src=\"env\", object_name=\"goal_0\", time_ref=\"curr\")\n    goal_1_pos = default_api.get_position(src=\"env\", object_name=\"goal_1\", time_ref=\"curr\")\n\n    # Thresholds\n    GRIPPER_CUBE_THRESHOLD = 0.05\n    CUBE_GOAL_THRESHOLD = 0.04\n\n    if subtask_id == 0:  # move_to_cube_0\n        dist = default_api.get_dist_xyz(gripper_pos.to_tuple(), cube_0_pos.to_tuple())[\"distance\"]\n        initial_dist = default_api.get_dist_xyz(\n            default_api.get_position(src=\"env\", object_name=\"gripper\", time_ref=\"prev\").to_tuple(),\n            default_api.get_position(src=\"env\", object_name=\"cube_0\", time_ref=\"prev\").to_tuple(),\n        )[\"distance\"]\n        progress = 1.0 - (dist / initial_dist) if initial_dist > 0 else 1.0\n        return max(0.0, min(1.0, progress))\n    elif subtask_id == 1:  # pick_cube_0\n        dist = default_api.get_dist_xyz(gripper_pos.to_tuple(), cube_0_pos.to_tuple())[\"distance\"]\n        return max(0.0, min(1.0, 1.0 - (dist / GRIPPER_CUBE_THRESHOLD)))\n    elif subtask_id == 2:  # move_cube_0_to_goal_0\n        dist = default_api.get_dist_xyz(cube_0_pos.to_tuple(), goal_0_pos.to_tuple())[\"distance\"]\n        initial_dist = default_api.get_dist_xyz(\n            default_api.get_position(src=\"env\", object_name=\"cube_0\", time_ref=\"prev\").to_tuple(),\n            default_api.get_position(src=\"env\", object_name=\"goal_0\", time_ref=\"prev\").to_tuple(),\n        )[\"distance\"]\n        progress = 1.0 - (dist / initial_dist) if initial_dist > 0 else 1.0\n        return max(0.0, min(1.0, progress))\n    elif subtask_id == 3:  # place_cube_0_at_goal_0\n        dist = default_api.get_dist_xyz(cube_0_pos.to_tuple(), goal_0_pos.to_tuple())[\"distance\"]\n        return max(0.0, min(1.0, 1.0 - (dist / CUBE_GOAL_THRESHOLD)))\n    elif subtask_id == 4:  # move_to_cube_1\n        dist = default_api.get_dist_xyz(gripper_pos.to_tuple(), cube_1_pos.to_tuple())[\"distance\"]\n        initial_dist = default_api.get_dist_xyz(\n            default_api.get_position(src=\"env\", object_name=\"gripper\", time_ref=\"prev\").to_tuple(),\n            default_api.get_position(src=\"env\", object_name=\"cube_1\", time_ref=\"prev\").to_tuple(),\n        )[\"distance\"]\n        progress = 1.0 - (dist / initial_dist) if initial_dist > 0 else 1.0\n        return max(0.0, min(1.0, progress))\n    elif subtask_id == 5:  # pick_cube_1\n        dist = default_api.get_dist_xyz(gripper_pos.to_tuple(), cube_1_pos.to_tuple())[\"distance\"]\n        return max(0.0, min(1.0, 1.0 - (dist / GRIPPER_CUBE_THRESHOLD)))\n    elif subtask_id == 6:  # move_cube_1_to_goal_1\n        dist = default_api.get_dist_xyz(cube_1_pos.to_tuple(), goal_1_pos.to_tuple())[\"distance\"]\n        initial_dist = default_api.get_dist_xyz(\n            default_api.get_position(src=\"env\", object_name=\"cube_1\", time_ref=\"prev\").to_tuple(),\n            default_api.get_position(src=\"env\", object_name=\"goal_1\", time_ref=\"prev\").to_tuple(),\n        )[\"distance\"]\n        progress = 1.0 - (dist / initial_dist) if initial_dist > 0 else 1.0\n        return max(0.0, min(1.0, progress))\n    elif subtask_id == 7:  # place_cube_1_at_goal_1\n        dist = default_api.get_dist_xyz(cube_1_pos.to_tuple(), goal_1_pos.to_tuple())[\"distance\"]\n        return max(0.0, min(1.0, 1.0 - (dist / CUBE_GOAL_THRESHOLD)))\n    return 0.0\n\n\ndef determine_subtask_and_progress(prev_env, curr_env) -> tuple[int, float]:\n    subtask_id = determine_subtask(prev_env, curr_env)\n    progress = measure_subtask_progress(prev_env, curr_env, subtask_id)\n    return subtask_id, progress"
}